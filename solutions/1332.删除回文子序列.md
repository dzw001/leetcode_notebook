### 题目链接
https://leetcode-cn.com/problems/remove-palindromic-subsequences/

### 题目描述
题目难度：```简单```

给你一个字符串 ```s```，它仅由字母 ```'a'``` 和 ```'b'``` 组成。每一次删除操作都可以从 ```s``` 中删除一个回文 **子序列** 。

返回删除给定字符串中所有字符（字符串为空）的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。

**示例 1：**
```
输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
```

**示例 2：**
```
输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "". 
先删除回文子序列 "a"，然后再删除 "bb"。
```

**示例 3：**
```
输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "". 
先删除回文子序列 "baab"，然后再删除 "b"。
```

### 解题思路
这道题的重点在于看清题意，题中所谓的 **子序列** 是不要求连续的，因此最差的情况就是先把 ```'a'``` 全部删除，再把 ```'b'``` 全部删除，两次就可删空整个字符串（因为全 ```'a'``` 和全 ```'b'``` 组成的 **子序列** 一定是回文的）。

看清题意之后，只需判断字符串本身是否为回文字符串即可，如果是的话，**一次删除** 即可达到目的；如果不是的话，则需要 **两次删除** 。

```python
# Python3
# Author: duzhenwei
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        i, j = 0, len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return 2
            i += 1
            j -= 1
        return 1
```
