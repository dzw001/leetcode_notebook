### 题目链接
https://leetcode-cn.com/problems/elimination-game/

### 题目描述
题目难度：```中等```

列表 ```arr``` 由在范围 ```[1, n]``` 中的所有整数组成，并按严格递增排序。请你对 ```arr``` 应用下述算法：

- 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
- 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
- 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 ```n``` ，返回 ```arr``` 最后剩下的数字。

**提示：**

- ```1 <= n <= 1e9```

### 解题思路
- 直接模拟的时间复杂度是O(n*logn)，而 ```n``` 的范围达到了10的9次方，肯定是要超时的，因此需要找一下规律。
- 假设 ```m = 1, 2, 3, 4, ...``` ，可以计算出每次删除后，所剩下的数字的递推式:

![递推式示意图](../assets/390.题解示意图(详细版).png)

由上图可以看出，递推式总是一个 *一次函数* ，因此可以假设其为 ```f[m] = a[i] * m + b[i]``` ，其中 ```i = 0, 1, 2, 3, ...``` 表示该递推式是第 ```i``` 次删除后的递推式。则：
  - 在未进行删除时，递推式为 ```f[m] = m``` ，因此 ```a[0] = 1``` ，```b[0] = 0```;
  - 若是 *正向* 删除，或是在剩余数字的数量为 *奇数* 时进行 *逆向* 删除，则删除后递推式由 ```a[i] * m + b[i]``` 变为 ```a[i] * (2m) + b[i]``` ，即 ```a[i+1] = a[i] * 2``` ，```b[i+1] = b[i]```；
  - 若是 *逆向* 删除，且当前剩余数字的数量为偶数，则递推式由 ```a[i] * m + b[i]``` 变为 ```a[i] * (2m-1) + b[i]``` ，即 ```a[i+1] = a[i] * 2``` ，```b[i+1] = b[i] - a[i]```。

根据上述规则，我们可以避免直接模拟，而是计算每次删除后递推式中的两个系数，最后当剩余数字的数量为 1 时，将 ```m = 1``` 带入递推式，即可得到当前所剩数字的值。

```python
# Python3
# Author: duzhenwei
class Solution:
    def lastRemaining(self, n: int) -> int:
        a, b = 1, 0
        count = n
        # flag 用于表示当前是从左到右(True)还是从右到左(False)
        flag = True
        while count > 1:
            if flag or count % 2 == 1:
                a *= 2
            else:
                b -= a
                a *= 2
            count //= 2
            flag = not flag
        return a + b
```