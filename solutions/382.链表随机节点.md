### 题目链接
https://leetcode-cn.com/problems/linked-list-random-node/

### 题目描述
题目难度：```中等```

给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。

实现 ```Solution``` 类：

- ```Solution(ListNode head)``` 使用整数数组初始化对象。
- ```int getRandom()``` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

### 解题思路
这道题是 2019 年刚上研一时，在北航门口的 Bigo 参加实习生现场面试时被问到过的一道题，当时的原题大致是 *要处理一个文本，但由于这个文本非常非常非常长，因此每次只能读取其中的一行到内存中，且预先不知道这个文本具体有多少行。问怎么通过一次遍历，就实现从中随机的抽取一行，并使每行被抽到的概率是相等的* 。这一晃间硕士都快要毕业了，回想当初连中序遍历都写不利索，这几年也算是大有长进了，哈哈哈哈。

当时被问到这道题，自然是没有答出来的，但面试官现场给我在纸上写递推式并讲解了一下解题思路，至今都记忆犹新。今天看到这道题，立马就想起了那个方法。提交通过之后看了眼题解，才知道这个方法叫做 **蓄水池抽样** 。

言归正传，**蓄水池抽样** 的应用场景可以概括为：样本总量未知，从所有样本中抽取若干个，要不每个样本被抽到的概率相等。

具体的操作是：用 ```res``` 来记录最终返回的结果，从前往后依次遍历每个样本，当遍历到第 *i* 个样本时，有 *1 / i* 的概率将第 *i* 个样本赋值给 ```res``` ：

- 当处理第 1 个样本时，将第 1 个样本赋值给 ```res``` 的概率是 1
- 当处理第 2 个样本时，```res``` 所保存的必然是第一个样本，此时我们以 *1/2* 的概率将第 2 个样本赋值给 ```res``` ，这样，到此为止，```P(res保存的是第 1 个样本) = P(res保存的是第 2 个样本) = 1/2```  
- 当处理第 3 个样本时，无论当前 ```res``` 中保存的是哪个样本，我们都以 *1/3* 的将其替换为第 3 个样本，这样的话：
  - 首先显然 ```P(res保存的是第 3 个样本) = 1/3```
  - 其次，```P(res保存的是第 2 个样本) = P(在处理第 3 个样本时未发生替换) * P(在处理第 3 个样本前res中保存的是第 2 个样本) = 2/3 * 1/2 = 1/3```
  - 最后，```P(res保存的是第 1 个样本) = P(在处理第 3 个样本时未发生替换) * P(在处理第 3 个样本前res中保存的是第 1 个样本) = 2/3 * 1/2 = 1/3```
  - 显然 3 个样本被选中的概率是相等的
- 以此类推，处理到第 ```n``` 个样本时，可以保证所有 ```n``` 个样本被抽取的概率实现相等的。

```python
# Python3
# Author: duzhenwei
import random

class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.head = head

    def getRandom(self) -> int:
        count = 1
        p = self.head
        res = None
        while p:
            if random.random() < 1 / count:
                res = p.val
            p = p.next
            count += 1
        return res
```