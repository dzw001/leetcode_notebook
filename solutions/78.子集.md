### 题目链接
https://leetcode-cn.com/problems/subsets/

### 题目描述
题目难度：```中等```

给你一个整数数组 ```nums``` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例1：**
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

### 解题思路
假如 ```nums``` 是一个包涵了三个元素的列表 ```nums = [1, 2, 4]```，那么我们先来从小到大地列出所有三位的二进制数：
1. ```000```
2. ```001```
3. ```010```
4. ```011```
5. ```100```
6. ```101```
7. ```110```
8. ```111```

现在我们制定一个规则，来利用上面的 8 个二进制数，从 ```nums``` 中选择元素构成子集：
- 如果二进制数的第一位上是 1 ，则将 ```nums``` 的第一个元素放入子集；如果第一位上是 0 ，则跳过 ```nums``` 的第一个元素，不将其放入子集；第二、第三位也以此类推。

由上述规则，我们可以得到如下的 8 个子集：
- ```[]```
- ```[3]```
- ```[2]```
- ```[2, 3]```
- ```[1]```
- ```[1, 3]```
- ```[1, 2]```
- ```[1, 2, 3]```

可以看出上述的子集恰是 ```nums``` 的所有不重复子集，因此此题的解法就是遍历位数等于 ```nums``` 长度的所有二进制数 ```range(0, 2 ** len(nums))``` ，每一个二进制数对应着 ```nums``` 的一个子集，根据每个二进制数中 1 所在的位数，将对应位置的元素放入子集即可。

```python
# Python3
# Author: duzhenwei
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        for i in range(2 ** len(nums)):
            sub_set = []
            idx = 0
            while i > 0:
                if i % 2 == 1:
                    sub_set.append(nums[idx])
                i >>= 1
                idx += 1
            res.append(sub_set)
        return res
```