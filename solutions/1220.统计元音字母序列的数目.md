### 题目链接
https://leetcode-cn.com/problems/count-vowels-permutation/

### 题目描述
题目难度：```困难```

给你一个整数 ```n```，请你帮忙统计一下我们可以按下述规则形成多少个长度为 ```n``` 的字符串：

字符串中的每个字符都应当是小写元音字母（```'a'```, ```'e'```, ```'i'```, ```'o'```, ```'u'```）
每个元音 ```'a'``` 后面都只能跟着 ```'e'```
每个元音 ```'e'``` 后面只能跟着 ```'a'``` 或者是 ```'i'```
每个元音 ```'i'``` 后面 不能 再跟着另一个 ```'i'```
每个元音 ```'o'``` 后面只能跟着 ```'i'``` 或者是 ```'u'```
每个元音 ```'u'``` 后面只能跟着 ```'a'```
由于答案可能会很大，所以请你返回 模 ```10^9 + 7``` 之后的结果。

### 解题思路
直接模拟会超时。我们以 **动态规划** 的思路来思考这个问题。先来考虑 *状态转移* 的规则：

假设长度为 ```x``` 时，所有符合题目规则的字符串中：

- 以 ```'a'``` 结尾的字符串有 ```aa``` 个
- 以 ```'e'``` 结尾的字符串有 ```ee``` 个
- 以 ```'i'``` 结尾的字符串有 ```ii``` 个
- 以 ```'o'``` 结尾的字符串有 ```oo``` 个
- 以 ```'u'``` 结尾的字符串有 ```uu``` 个

则根据题目的规则可以推断出，当长度为 ```x + 1``` 时，所有符合题目规则的字符串中：

- 以 ```'a'``` 结尾的字符串有 ```ee + ii + uu``` 个（ 因为根据规则，在原本长为 ```x``` 的所有合法字符串中，只有以 ```'e'``` 、```'i'``` 、```'u'``` 结尾的字符串可以合法地在尾部添加一个 ```'a'``` 来形成新的字符串。下同。 ）
- 以 ```'e'``` 结尾的字符串有 ```aa + ii``` 个
- 以 ```'i'``` 结尾的字符串有 ```ee + oo``` 个
- 以 ```'o'``` 结尾的字符串有 ```ii``` 个
- 以 ```'u'``` 结尾的字符串有 ```ii + oo``` 个

总结出了上述的规则之后，再来看初始的状态。显然在 ```x = 1``` 时，字符串中只包涵单个字母，即 ```aa = ee = ii = oo = uu = 1``` 。

最后，只需根据初始状态，以及在 ```x``` 增加时的状态转移规则，即可递推出 ```x = n``` 时以 ```'a'``` 、 ```'e'``` 、 ```'i'``` 、 ```'o'``` 、 ```'u'``` 结尾的字符串各有多少个，然后求和即可。

返回结果时记得按照题意对结果进行取模运算。

```python
# Python3
# Author: duzhenwei
class Solution:
    def countVowelPermutation(self, n: int) -> int:
        end_with = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}
        for x in range(2, n + 1):
            aa, end_with['a'] = end_with['a'], 0
            ee, end_with['e'] = end_with['e'], 0
            ii, end_with['i'] = end_with['i'], 0
            oo, end_with['o'] = end_with['o'], 0
            uu, end_with['u'] = end_with['u'], 0
            end_with['a'] = ee + ii + uu
            end_with['e'] = aa + ii
            end_with['i'] = ee + oo
            end_with['o'] = ii
            end_with['u'] = ii + oo
        return sum(list(end_with.values())) % (10 ** 9 + 7)
```
