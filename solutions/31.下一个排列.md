### 题目链接
https://leetcode-cn.com/problems/next-permutation/

### 题目描述
题目难度：```中等```

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中 *下一个更大的排列*（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 [原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 修改，只允许使用额外常数空间。

提示：

- ```1 <= nums.length <= 100```
- ```0 <= nums[i] <= 100```


**个人注释**：

题目中给的条件是 ```0 <= nums[i] <= 100``` ，那么这里说的 *组合出下一个更大的整数* 就会有些歧义，比如数组 ```[66, 9, 7]``` 和 ```[9, 7, 66]``` ，经过测试后发现在官方的评判标准中，前者才是 *更大* 的那个。

因此准确地说应该是 **在101进制下，组合出一个更大的整数**。再比如，假如题目中给的限制是 ```0 <= nums[i] <= 15``` ,则应该是 **在16进制下，组合出一个更大的整数** 。

### 解题思路
解题思路有些零碎，分成几块来写：

---
前提：

- 我们所能进行的唯一一种操作就是交换 ```nums``` 中不同元素的位置。
- 先考虑一个纯粹的数字，例如 ```4523``` ，如果我们想交换它的其中两位数，使它变成 *下一个更大的排列* ，那么我们肯定是要交换 2 和 3，而不是交换 4 和 5 。因为我们操作的位数越低，对原始大小的扰动就越小。
- 类比于上一条，如果要把当前的 ```nums``` 变成 *下一个更大的排列* ，就要尽可能的交换 ```nums``` 中位置更靠后的元素。

---
举例：

- 假设 ```nums = [9, 5, 6, 3, 1, 4, 2, 0]``` ，基于 *尽量操作位置靠后的元素* 的原则，我们从最后一位往前看，显然最后三位递减的数字 ```[4, 2, 0]``` 已经构成了其所能组成的最大的三位数，无论怎么交换都只能使 *排列* 变得更小。由此也能发现，**我们需要找出 ```nums``` 的第一个 *非单调递减* 的后缀数组**。
- 基于上一条，我们可以找出子数组 ```[1, 4, 2, 0]``` ，要把它变成 *下一个更大的排列* ，主要分为两步：
  1. 把第一位的 ```1``` 换为 *比 1 大的数字中最小的* 那个数字，在这个子数组中也就是 ```2``` 了，此时的排列变为 ```[2, 4, 1, 0]```；
  2. 保证后三位上的排列是最小的，也就是单调递增的，因此 ```[2, 4, 1, 0]``` 变为 ```[2, 0, 1, 4]``` ，整个数组变为 ```[9, 5, 6, 3, 2, 0, 1, 4]``` ，变换完毕。

---
总结：

- 如果 ```nums``` 中的元素大小是单调递减的，则此时它们已经组合出了 *最大的排列* ，按照题意，只需要把整个数组逆序，得到 *最小的排列* 即可。
- 如果 ```nums``` 当前不是 *最大的排列* ，则其中必然存在若干个 *拐点* (若 ```nums[i] < nums[i - 1]``` 且 ```nums[i] < nums[i + 1]```，则称 ```nums[i]``` 为 *拐点* ，类比于函数图像上的极小值点)。例如上述的 ```[9, 5, 6, 3, 1, 4, 2, 0]``` 中， ```5``` 和 ```1``` 就是其 *拐点* 。
- 至少包涵一个 *拐点* 的子数组才有可能通过交换元素顺序变得更大。
- 基于 *尽量操作位置靠后的元素* 的原则，我们只关注最后一个 *拐点* 之后的子数组（如上述例子中的 ```[1, 4, 2, 0]``` ）：
  - 将 *大于第一个元素的最小的元素* 与第一个元素交换位置，以确保子数组 *变大* ；
  - 交换后将第一位之后的其余各位元素按照递增的顺序排列，以确保子数组 *以最小的幅度* 变大。

```python
# Python3
# Author: duzhenwei
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def swap(i, j):
            temp = nums[i]
            nums[i] = nums[j]
            nums[j] = temp
        idx = -1
        for i in range(len(nums) - 1):
            if nums[i] < nums[i + 1]:
                idx = i
        if idx == -1:
            i, j = 0, len(nums) - 1
            while i < j:
                swap(i, j)
                i += 1
                j -= 1
        else:
            i, j = idx + 1, len(nums) - 1
            while i < j:
                swap(i, j)
                i += 1
                j -= 1
            for i in range(idx + 1, len(nums)):
                if nums[i] > nums[idx]:
                    swap(i, idx)
                    break
```