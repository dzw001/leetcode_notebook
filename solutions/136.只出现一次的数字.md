### 题目链接
https://leetcode-cn.com/problems/single-number/

### 题目描述
题目难度：```简单```

给定一个 **非空** 整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### 解题思路
题目本身并不难，利用哈希表，或者先对数组进行一次排序，就能轻松地解出来。但在题解区看到了一个非常有意思的思路，感觉很值得记录下来。

**只要对数组中的所有元素进行 *异或* 操作，最终的计算结果就恰等于那个 *只出现了一次的元素*。**

要理解面这种方法，首先要知道：

1. *异或* 运算是满足 **交换律** 的，即 ```a^b = b^a```
2. 相同的数字进行 *异或* 后，必然等于 0，即 ```a^a = 0```
3. 任何数与 0 进行 *异或* 的结果都等于其本身，即 ```a^0 = a```

由上述三条就可知，假如数组为 ```[a, b, a]``` ，则对其所有元素进行 *异或* ，就有：
```
a^b^a = a^a^b = 0^b = b
```
即得到了 *只出现了一次的元素*。

```python
# Python3
# Author: duzhenwei
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = nums[0]
        for num in nums[1: ]:
            res ^= num
        return res
```