### 题目链接
https://leetcode-cn.com/problems/longest-duplicate-substring/

### 题目描述
题目难度：```困难```

给你一个字符串 ```s``` ，考虑其所有 **重复子串** ：即，```s``` 的连续子串，在 ```s``` 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 **任意一个** 具有最长长度的重复子串。如果 ```s``` 不含重复子串，那么答案为 ```""``` 。

### 解题思路
虽然是困难题，但是在 Python 里可以用比较简单的方法通过，就是耗时非常非常长。

设定 ```i``` 、 ```j``` 为 **子串** 的头、尾下标，则显然 ```s[i: j]``` 为 ```s``` 的子串，因此只需判断在 ```s[i + 1: ]``` 中是否也存在该子串即可
    
- 若存在，则当前的 ```s[i: j]``` 是符合要求的，不需要再考虑长度小于等于 ```j - i``` 的子串，因此将 ```j``` 加一（右移一位）。
- 若不存在，当前的 ```s[i: j]``` 是不符合要求的，且对于 ```s``` 的其他子串，只要包涵了当前 ```s[i: j]``` ，就一定不符合要求。因此此时将 ```i``` 和 ```j``` 同时加一（右移一位）。

```python
# Python3
# Author: duzhenwei
class Solution:
    def longestDupSubstring(self, s: str) -> str:
        ans = ''
        i, j = 0, 1
        while i < len(s):
            if s[i: j] in s[i + 1:]:
                ans = s[i: j]
            else:
                i += 1
            j += 1
        return ans
```